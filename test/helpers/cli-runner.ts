/**
 * CLI Test Helper
 * Provides utilities for spawning and testing the gh-please CLI
 */

import type { Subprocess } from 'bun'
import { describe, expect } from 'bun:test'

export interface CliResult {
  exitCode: number | null
  stdout: string
  stderr: string
  success: boolean
}

export interface CliRunOptions {
  cwd?: string
  env?: Record<string, string>
  timeout?: number
}

/**
 * Runs the gh-please CLI with given arguments
 * @param args - Command line arguments (e.g., ['ai', 'triage', '123'])
 * @param options - Execution options
 * @returns Promise with exit code, stdout, stderr
 */
export async function runCli(
  args: string[],
  options: CliRunOptions = {},
): Promise<CliResult> {
  const {
    cwd = process.cwd(),
    env = {},
    timeout = 10000,
  } = options

  // Build command - use the source entry point for testing
  const command = [
    'bun',
    'run',
    'src/index.ts',
    ...args,
  ]

  const proc = Bun.spawn(command, {
    cwd,
    env: {
      ...process.env,
      ...env,
    },
    stdout: 'pipe',
    stderr: 'pipe',
  })

  // Create timeout promise
  const timeoutPromise = new Promise<never>((_, reject) => {
    setTimeout(() => reject(new Error(`CLI command timed out after ${timeout}ms`)), timeout)
  })

  try {
    // Race between process completion and timeout
    await Promise.race([
      proc.exited,
      timeoutPromise,
    ])

    const stdout = await new Response(proc.stdout).text()
    const stderr = await new Response(proc.stderr).text()
    const exitCode = proc.exitCode

    return {
      exitCode,
      stdout: stdout.trim(),
      stderr: stderr.trim(),
      success: exitCode === 0,
    }
  }
  catch (error) {
    proc.kill()
    throw error
  }
}

/**
 * Runs CLI and expects success (exit code 0)
 */
export async function runCliExpectSuccess(
  args: string[],
  options?: CliRunOptions,
): Promise<CliResult> {
  const result = await runCli(args, options)

  if (!result.success) {
    throw new Error(
      `Expected CLI to succeed but got exit code ${result.exitCode}\n` +
      `stdout: ${result.stdout}\n` +
      `stderr: ${result.stderr}`,
    )
  }

  return result
}

/**
 * Runs CLI and expects failure (non-zero exit code)
 */
export async function runCliExpectFailure(
  args: string[],
  options?: CliRunOptions,
): Promise<CliResult> {
  const result = await runCli(args, options)

  if (result.success) {
    throw new Error(
      `Expected CLI to fail but it succeeded\n` +
      `stdout: ${result.stdout}\n` +
      `stderr: ${result.stderr}`,
    )
  }

  return result
}

/**
 * Asserts CLI output contains expected text
 */
export function assertOutputContains(
  result: CliResult,
  expectedText: string,
  source: 'stdout' | 'stderr' | 'any' = 'stdout',
): void {
  const text = source === 'any'
    ? `${result.stdout}\n${result.stderr}`
    : source === 'stdout'
      ? result.stdout
      : result.stderr

  expect(text).toContain(expectedText)
}

/**
 * Asserts CLI output matches regex pattern
 */
export function assertOutputMatches(
  result: CliResult,
  pattern: RegExp,
  source: 'stdout' | 'stderr' | 'any' = 'stdout',
): void {
  const text = source === 'any'
    ? `${result.stdout}\n${result.stderr}`
    : source === 'stdout'
      ? result.stdout
      : result.stderr

  expect(text).toMatch(pattern)
}

/**
 * Asserts CLI exit code
 */
export function assertExitCode(result: CliResult, expectedCode: number): void {
  expect(result.exitCode).toBe(expectedCode)
}

/**
 * Mock GitHub CLI (gh) for integration testing
 * Returns a function that restores the original behavior
 */
export interface GhMockResponse {
  stdout?: string
  stderr?: string
  exitCode?: number
  delay?: number
}

export interface GhMockRule {
  args: string[] | RegExp
  response: GhMockResponse
}

/**
 * Creates a mock gh command script for testing
 * This allows testing CLI behavior without making real GitHub API calls
 */
export async function createGhMock(
  mockRules: GhMockRule[],
  mockScriptPath = '/tmp/gh-mock.sh',
): Promise<() => void> {
  // Generate mock script
  const mockScript = `#!/usr/bin/env bash
# Mock GitHub CLI for testing
# Generated by cli-runner.ts

ARGS="$@"

${mockRules.map((rule, index) => {
    const pattern = rule.args instanceof RegExp
      ? rule.args.source
      : rule.args.join(' ')

    const stdout = rule.response.stdout ?? ''
    const stderr = rule.response.stderr ?? ''
    const exitCode = rule.response.exitCode ?? 0
    const delay = rule.response.delay ?? 0

    return `
# Rule ${index + 1}
if [[ "$ARGS" == ${pattern instanceof RegExp ? `*${pattern}*` : `"${pattern}"`} ]]; then
  ${delay > 0 ? `sleep ${delay / 1000}` : ''}
  echo "${stdout}"
  >&2 echo "${stderr}"
  exit ${exitCode}
fi
`
  }).join('\n')}

# No rule matched
>&2 echo "gh-mock: No rule matched for args: $ARGS"
exit 1
`

  // Write mock script
  await Bun.write(mockScriptPath, mockScript)
  await Bun.spawn(['chmod', '+x', mockScriptPath]).exited

  // Modify PATH to use mock
  const originalPath = process.env.PATH
  const mockDir = mockScriptPath.substring(0, mockScriptPath.lastIndexOf('/'))
  process.env.PATH = `${mockDir}:${originalPath}`

  // Return cleanup function
  return () => {
    process.env.PATH = originalPath
    // Clean up mock script
    try {
      Bun.spawn(['rm', mockScriptPath])
    }
    catch {
      // Ignore cleanup errors
    }
  }
}

/**
 * Helper to extract issue/PR numbers from CLI output
 */
export function extractIssueNumber(output: string): number | null {
  const match = output.match(/#(\d+)/)
  return match ? Number.parseInt(match[1], 10) : null
}

/**
 * Helper to extract URLs from CLI output
 */
export function extractUrl(output: string): string | null {
  const match = output.match(/https:\/\/github\.com\/[^\s]+/)
  return match ? match[0] : null
}

/**
 * Test helper for checking CLI help output
 */
export async function testHelpOutput(commandArgs: string[]): Promise<void> {
  const result = await runCli([...commandArgs, '--help'])

  expect(result.success).toBe(true)
  expect(result.stdout).toContain('Usage:')
  expect(result.stdout.length).toBeGreaterThan(0)
}

/**
 * Test helper for checking version output
 */
export async function testVersionOutput(): Promise<void> {
  const result = await runCli(['--version'])

  expect(result.success).toBe(true)
  expect(result.stdout).toMatch(/\d+\.\d+\.\d+/)
}

/**
 * Creates a temporary test directory with git initialized
 */
export async function createTestRepo(name = 'test-repo'): Promise<string> {
  const tmpDir = `/tmp/gh-please-test-${Date.now()}-${name}`

  await Bun.spawn(['mkdir', '-p', tmpDir]).exited
  await Bun.spawn(['git', 'init'], { cwd: tmpDir }).exited
  await Bun.spawn(['git', 'config', 'user.name', 'Test User'], { cwd: tmpDir }).exited
  await Bun.spawn(['git', 'config', 'user.email', 'test@example.com'], { cwd: tmpDir }).exited

  return tmpDir
}

/**
 * Cleans up a test repository
 */
export async function cleanupTestRepo(repoPath: string): Promise<void> {
  await Bun.spawn(['rm', '-rf', repoPath]).exited
}
