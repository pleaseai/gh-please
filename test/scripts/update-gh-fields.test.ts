import { existsSync, readFileSync, unlinkSync, writeFileSync } from 'node:fs'
import { join } from 'node:path'
import { afterEach, beforeEach, describe, expect, test } from 'bun:test'

/**
 * Tests for update-gh-fields.ts script
 *
 * These tests verify that the field extraction script correctly:
 * - Extracts fields from gh CLI error messages
 * - Generates TypeScript file with proper format
 * - Handles errors (no gh auth, invalid commands)
 * - Formats field strings correctly (comma-separated, no spaces)
 */

// Mock data for testing
const MOCK_GH_ERROR_OUTPUT = `unknown field: "invalidfield"
Available fields for 'gh issue view':
  assignees
  author
  body
  createdAt
  number
  title
  url`

const MOCK_GH_VERSION_OUTPUT = 'gh version 2.82.0 (2025-01-15)'

describe('update-gh-fields script', () => {
  const GENERATED_FILE_PATH = join(process.cwd(), 'src', 'lib', 'gh-fields.generated.ts')
  const BACKUP_FILE_PATH = `${GENERATED_FILE_PATH}.backup`
  let originalGeneratedFile: string | null = null

  beforeEach(() => {
    // Backup original generated file if it exists
    if (existsSync(GENERATED_FILE_PATH)) {
      originalGeneratedFile = readFileSync(GENERATED_FILE_PATH, 'utf-8')
      writeFileSync(BACKUP_FILE_PATH, originalGeneratedFile, 'utf-8')
    }
  })

  afterEach(() => {
    // Restore original generated file
    if (originalGeneratedFile !== null) {
      writeFileSync(GENERATED_FILE_PATH, originalGeneratedFile, 'utf-8')
    }
    else if (existsSync(GENERATED_FILE_PATH)) {
      unlinkSync(GENERATED_FILE_PATH)
    }
    // Clean up backup
    if (existsSync(BACKUP_FILE_PATH)) {
      unlinkSync(BACKUP_FILE_PATH)
    }
  })

  describe('field extraction', () => {
    test('should extract fields from gh CLI error message', () => {
      // Arrange
      const errorOutput = MOCK_GH_ERROR_OUTPUT

      // Act
      const lines = errorOutput.split('\n')
      const availableFieldsIndex = lines.findIndex(line => line.includes('Available fields'))
      const fields = lines
        .slice(availableFieldsIndex + 1)
        .map(line => line.trim())
        .filter(line => line && !line.includes(':'))

      // Assert
      expect(fields).toEqual(['assignees', 'author', 'body', 'createdAt', 'number', 'title', 'url'])
    })

    test('should parse "Available fields:" section correctly', () => {
      // Arrange
      const complexErrorOutput = `Error: unknown field: "invalidfield"

Available fields for 'gh pr view':
  additions
  assignees
  author
  body
  createdAt

Use --help for more information.`

      // Act
      const lines = complexErrorOutput.split('\n')
      const availableFieldsIndex = lines.findIndex(line => line.includes('Available fields'))
      const fields = lines
        .slice(availableFieldsIndex + 1)
        .map(line => line.trim())
        .filter(line => line && !line.includes(':') && !line.startsWith('Use '))

      // Assert
      expect(fields).toContain('additions')
      expect(fields).toContain('assignees')
      expect(fields).toContain('author')
      expect(fields).toContain('body')
      expect(fields).toContain('createdAt')
    })

    test('should format fields as comma-separated string with no spaces', () => {
      // Arrange
      const fields = ['assignees', 'author', 'body', 'createdAt', 'number', 'title']

      // Act
      const formatted = fields.join(',')

      // Assert
      expect(formatted).toBe('assignees,author,body,createdAt,number,title')
      expect(formatted).not.toContain(' ') // No spaces
    })

    test('should handle empty field list', () => {
      // Arrange
      const fields: string[] = []

      // Act
      const formatted = fields.join(',')

      // Assert
      expect(formatted).toBe('')
    })

    test('should handle single field', () => {
      // Arrange
      const fields = ['title']

      // Act
      const formatted = fields.join(',')

      // Assert
      expect(formatted).toBe('title')
    })
  })

  describe('generated file creation', () => {
    test('should generate file with correct structure', () => {
      // Arrange
      const fieldMappings = {
        'issue view': 'assignees,author,body,title',
        'pr view': 'additions,assignees,author,body',
      }
      const timestamp = '2025-10-30'
      const ghVersion = '2.82.0'

      // Act
      const content = `// Auto-generated by scripts/update-gh-fields.ts
// DO NOT EDIT MANUALLY - Run: bun run update-fields
//
// Last updated: ${timestamp}
// gh CLI version: ${ghVersion}

/**
 * GitHub CLI JSON field mappings for view commands.
 *
 * These field definitions are used to inject --json <fields> when users
 * request TOON or JSON format conversion for view commands.
 *
 * View commands (issue view, pr view, etc.) require explicit field specification,
 * while list commands work with just --json flag.
 */
export const GH_JSON_FIELDS: Record<string, string> = {
${Object.entries(fieldMappings)
  .map(([key, value]) => `  '${key}': '${value}',`)
  .join('\n')}
}
`

      // Assert
      expect(content).toContain('Auto-generated by scripts/update-gh-fields.ts')
      expect(content).toContain('DO NOT EDIT MANUALLY')
      expect(content).toContain(`Last updated: ${timestamp}`)
      expect(content).toContain(`gh CLI version: ${ghVersion}`)
      expect(content).toContain('export const GH_JSON_FIELDS')
      expect(content).toContain('\'issue view\': \'assignees,author,body,title\'')
      expect(content).toContain('\'pr view\': \'additions,assignees,author,body\'')
    })

    test('should generate valid TypeScript syntax', () => {
      // Act
      const content = `export const GH_JSON_FIELDS: Record<string, string> = {
  'issue view': 'assignees,author,body',
}
`

      // Assert - Should be valid TypeScript (no syntax errors)
      expect(content).toContain('Record<string, string>')
      expect(content).toMatch(/^export const/)
      expect(content.trimEnd()).toMatch(/\}$/) // Content ends with closing brace and newline
    })

    test('should handle multiple command mappings', () => {
      // Arrange
      const fieldMappings = {
        'issue view': 'assignees,author',
        'pr view': 'additions,assignees',
        'repo view': 'name,owner',
        'release view': 'tagName,assets',
      }

      // Act
      const entries = Object.entries(fieldMappings)

      // Assert
      expect(entries).toHaveLength(4)
      expect(entries[0]).toEqual(['issue view', 'assignees,author'])
      expect(entries[1]).toEqual(['pr view', 'additions,assignees'])
      expect(entries[2]).toEqual(['repo view', 'name,owner'])
      expect(entries[3]).toEqual(['release view', 'tagName,assets'])
    })
  })

  describe('error handling', () => {
    test('should detect when gh CLI is not authenticated', () => {
      // Arrange
      const mockAuthError = {
        stdout: '',
        stderr: 'You are not logged into any GitHub hosts. Run gh auth login to authenticate.',
        exitCode: 1,
      }

      // Act
      const isAuthenticated = mockAuthError.exitCode === 0

      // Assert
      expect(isAuthenticated).toBe(false)
      expect(mockAuthError.stderr).toContain('not logged into')
    })

    test('should handle invalid command gracefully', () => {
      // Arrange
      const mockInvalidCommandError = {
        stdout: '',
        stderr: 'unknown command "invalidcmd" for "gh"',
        exitCode: 1,
      }

      // Act
      const isValidCommand = mockInvalidCommandError.exitCode === 0

      // Assert
      expect(isValidCommand).toBe(false)
      expect(mockInvalidCommandError.stderr).toContain('unknown command')
    })

    test('should handle missing "Available fields:" section', () => {
      // Arrange
      const errorWithoutFields = 'Error: something went wrong'

      // Act
      const hasAvailableFields = errorWithoutFields.includes('Available fields:')

      // Assert
      expect(hasAvailableFields).toBe(false)
    })

    test('should provide helpful error message when field extraction fails', () => {
      // Arrange
      const command = 'issue'
      const subcommand = 'view'
      const stderr = 'Error: API rate limit exceeded'

      // Act
      const errorMessage = `Failed to extract fields for ${command} ${subcommand}\nStderr: ${stderr}`

      // Assert
      expect(errorMessage).toContain('Failed to extract fields')
      expect(errorMessage).toContain('issue view')
      expect(errorMessage).toContain(stderr)
    })
  })

  describe('gh version parsing', () => {
    test('should extract version number from gh version output', () => {
      // Arrange
      const versionOutput = MOCK_GH_VERSION_OUTPUT

      // Act
      const match = versionOutput.match(/gh version ([\d.]+)/)
      const version = match ? match[1] : 'unknown'

      // Assert
      expect(version).toBe('2.82.0')
    })

    test('should return "unknown" when version cannot be parsed', () => {
      // Arrange
      const invalidOutput = 'Something unexpected'

      // Act
      const match = invalidOutput.match(/gh version ([\d.]+)/)
      const version = match ? match[1] : 'unknown'

      // Assert
      expect(version).toBe('unknown')
    })

    test('should handle pre-release versions', () => {
      // Arrange
      const preReleaseOutput = 'gh version 2.83.0-pre.0 (2025-01-20)'

      // Act
      const match = preReleaseOutput.match(/gh version ([\d.]+)/)
      const version = match ? match[1] : 'unknown'

      // Assert
      expect(version).toBe('2.83.0')
    })
  })

  describe('command configuration', () => {
    test('should have valid test IDs for all configured commands', () => {
      // Arrange
      const commands = [
        { command: 'issue', subcommand: 'view', testId: '1' },
        { command: 'pr', subcommand: 'view', testId: '1' },
        { command: 'repo', subcommand: 'view', testId: 'pleaseai/gh-please' },
        { command: 'release', subcommand: 'view', testId: 'latest' },
      ]

      // Act & Assert
      for (const config of commands) {
        expect(config.command).toBeTruthy()
        expect(config.subcommand).toBe('view')
        expect(config.testId).toBeTruthy()
      }
    })

    test('should use numeric test ID for issue and pr commands', () => {
      // Arrange
      const issueConfig = { command: 'issue', subcommand: 'view', testId: '1' }
      const prConfig = { command: 'pr', subcommand: 'view', testId: '1' }

      // Act
      const issueIdIsNumeric = !Number.isNaN(Number(issueConfig.testId))
      const prIdIsNumeric = !Number.isNaN(Number(prConfig.testId))

      // Assert
      expect(issueIdIsNumeric).toBe(true)
      expect(prIdIsNumeric).toBe(true)
    })

    test('should use repo format for repo view command', () => {
      // Arrange
      const repoConfig = { command: 'repo', subcommand: 'view', testId: 'pleaseai/gh-please' }

      // Act
      const isValidRepoFormat = /^[\w-]+\/[\w-]+$/.test(repoConfig.testId)

      // Assert
      expect(isValidRepoFormat).toBe(true)
    })

    test('should use tag format for release view command', () => {
      // Arrange
      const releaseConfig = { command: 'release', subcommand: 'view', testId: 'latest' }

      // Act
      const isValidTagFormat = releaseConfig.testId === 'latest' || /^v?\d+\.\d+\.\d+/.test(releaseConfig.testId)

      // Assert
      expect(isValidTagFormat).toBe(true)
    })
  })

  describe('integration with generated file', () => {
    test('should load generated file successfully', async () => {
      // Arrange - Import the generated file
      const { GH_JSON_FIELDS } = await import('../../src/lib/gh-fields.generated')

      // Act & Assert
      expect(GH_JSON_FIELDS).toBeDefined()
      expect(typeof GH_JSON_FIELDS).toBe('object')
    })

    test('generated file should contain expected command mappings', async () => {
      // Arrange
      const { GH_JSON_FIELDS } = await import('../../src/lib/gh-fields.generated')

      // Act & Assert
      expect(GH_JSON_FIELDS['issue view']).toBeDefined()
      expect(GH_JSON_FIELDS['pr view']).toBeDefined()
      expect(GH_JSON_FIELDS['repo view']).toBeDefined()
      expect(GH_JSON_FIELDS['release view']).toBeDefined()
    })

    test('generated fields should be comma-separated strings', async () => {
      // Arrange
      const { GH_JSON_FIELDS } = await import('../../src/lib/gh-fields.generated')

      // Act & Assert
      for (const [_command, fields] of Object.entries(GH_JSON_FIELDS)) {
        expect(typeof fields).toBe('string')
        expect(fields).not.toContain(' ') // No spaces
        expect(fields.split(',').length).toBeGreaterThan(0) // At least one field
        expect(fields).not.toMatch(/^,|,$/) // No leading/trailing commas
      }
    })

    test('generated fields should contain expected field names', async () => {
      // Arrange
      const { GH_JSON_FIELDS } = await import('../../src/lib/gh-fields.generated')

      // Act & Assert
      // Issue view should have common fields
      expect(GH_JSON_FIELDS['issue view']).toContain('title')
      expect(GH_JSON_FIELDS['issue view']).toContain('body')
      expect(GH_JSON_FIELDS['issue view']).toContain('author')
      expect(GH_JSON_FIELDS['issue view']).toContain('number')

      // PR view should have PR-specific fields
      expect(GH_JSON_FIELDS['pr view']).toContain('additions')
      expect(GH_JSON_FIELDS['pr view']).toContain('deletions')
      expect(GH_JSON_FIELDS['pr view']).toContain('mergeable')
    })
  })
})
