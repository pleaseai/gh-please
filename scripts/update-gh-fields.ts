#!/usr/bin/env bun

/**
 * Update GitHub CLI Field Definitions
 *
 * This script extracts available JSON fields from GitHub CLI commands
 * and generates a TypeScript file with field mappings for use in
 * TOON/JSON format conversion.
 *
 * Usage:
 *   bun run scripts/update-gh-fields.ts
 *   npm run update-fields
 *
 * Output:
 *   src/lib/gh-fields.generated.ts
 */

import { execSync } from 'node:child_process'
import { writeFileSync } from 'node:fs'
import { join } from 'node:path'

interface CommandConfig {
  command: string
  subcommand: string
  testId: string
  description: string
}

// Commands to extract fields from
const COMMANDS: CommandConfig[] = [
  {
    command: 'issue',
    subcommand: 'view',
    testId: '1', // Generic test ID
    description: 'Issue view command',
  },
  {
    command: 'pr',
    subcommand: 'view',
    testId: '1', // Generic test ID
    description: 'Pull request view command',
  },
  {
    command: 'repo',
    subcommand: 'view',
    testId: 'pleaseai/gh-please', // Valid repo format
    description: 'Repository view command',
  },
  {
    command: 'release',
    subcommand: 'view',
    testId: 'latest', // Use 'latest' tag
    description: 'Release view command',
  },
]

/**
 * Execute a gh CLI command and capture output
 */
function executeGhCommand(args: string[]): { stdout: string, stderr: string, exitCode: number } {
  try {
    const stdout = execSync(`gh ${args.join(' ')}`, {
      encoding: 'utf-8',
      stdio: ['pipe', 'pipe', 'pipe'],
    })
    return { stdout, stderr: '', exitCode: 0 }
  }
  catch (error: any) {
    return {
      stdout: error.stdout?.toString() || '',
      stderr: error.stderr?.toString() || '',
      exitCode: error.status || 1,
    }
  }
}

/**
 * Extract available fields from gh CLI error message
 */
function extractFields(command: string, subcommand: string, testId: string): string[] {
  console.log(`üì° Extracting fields for: gh ${command} ${subcommand}`)

  const result = executeGhCommand([command, subcommand, testId, '--json', 'invalidfield'])

  if (result.stderr.includes('Available fields:')) {
    const fields = result.stderr
      .split('Available fields:')[1]
      .split('\n')
      .map(line => line.trim())
      .filter(line => line && !line.includes(':') && !line.includes('Unknown'))

    console.log(`   ‚úÖ Found ${fields.length} fields`)
    return fields
  }

  throw new Error(`Failed to extract fields for ${command} ${subcommand}\nStderr: ${result.stderr}`)
}

/**
 * Get current gh CLI version
 */
function getGhVersion(): string {
  try {
    const result = execSync('gh version', { encoding: 'utf-8' })
    const match = result.match(/gh version ([\d.]+)/)
    return match ? match[1] : 'unknown'
  }
  catch {
    return 'unknown'
  }
}

/**
 * Generate TypeScript file with field mappings
 */
function generateFieldsFile(fieldMappings: Record<string, string>): void {
  const ghVersion = getGhVersion()
  const timestamp = new Date().toISOString().split('T')[0]

  const content = `// Auto-generated by scripts/update-gh-fields.ts
// DO NOT EDIT MANUALLY - Run: bun run update-fields
//
// Last updated: ${timestamp}
// gh CLI version: ${ghVersion}

/**
 * GitHub CLI JSON field mappings for view commands.
 *
 * These field definitions are used to inject --json <fields> when users
 * request TOON or JSON format conversion for view commands.
 *
 * View commands (issue view, pr view, etc.) require explicit field specification,
 * while list commands work with just --json flag.
 */
export const GH_JSON_FIELDS: Record<string, string> = {
${Object.entries(fieldMappings)
  .map(([key, value]) => `  '${key}': '${value}',`)
  .join('\n')}
}
`

  const outputPath = join(process.cwd(), 'src', 'lib', 'gh-fields.generated.ts')
  writeFileSync(outputPath, content, 'utf-8')

  console.log(`\n‚úÖ Generated: ${outputPath}`)
  console.log(`   gh CLI version: ${ghVersion}`)
  console.log(`   Commands: ${Object.keys(fieldMappings).length}`)
}

/**
 * Main execution
 */
async function main(): Promise<void> {
  console.log('üöÄ Updating GitHub CLI field definitions...\n')

  // Check gh CLI authentication
  const authCheck = executeGhCommand(['auth', 'status'])
  if (authCheck.exitCode !== 0) {
    console.error('‚ùå GitHub CLI is not authenticated. Run: gh auth login')
    process.exit(1)
  }

  const fieldMappings: Record<string, string> = {}

  // Extract fields for each command
  for (const config of COMMANDS) {
    try {
      const fields = extractFields(config.command, config.subcommand, config.testId)
      const commandKey = `${config.command} ${config.subcommand}`
      fieldMappings[commandKey] = fields.join(',')
    }
    catch (error: any) {
      console.error(`‚ùå Error extracting fields for ${config.command} ${config.subcommand}:`)
      console.error(`   ${error.message}`)
      process.exit(1)
    }
  }

  // Generate TypeScript file
  try {
    generateFieldsFile(fieldMappings)
    console.log('\n‚ú® Field definitions updated successfully!')
    console.log('\nüí° Next steps:')
    console.log('   1. Review changes: git diff src/lib/gh-fields.generated.ts')
    console.log('   2. Test integration: bun test test/lib/gh-passthrough.test.ts')
    console.log('   3. Commit if changes exist: git add src/lib/gh-fields.generated.ts')
  }
  catch (error: any) {
    console.error('‚ùå Error generating fields file:')
    console.error(`   ${error.message}`)
    process.exit(1)
  }
}

// Run main function
main().catch((error) => {
  console.error('‚ùå Unexpected error:', error)
  process.exit(1)
})
